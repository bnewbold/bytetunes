
opcodes
    note: no unary, increment, decrement
    arthithmetic: + - * / %
    bitwise: l r & | ^ ~
    "<<" is l, ">>" is r
    all are atoms or binary operators, so recursive compilation to a forth-like?
    order of ops:
        ~
        * / %
        + -
        << >>
        &
        ^
        |

final console interface:
    #hashtag (exact) -> searches identica for tunes
    @username (exact) -> parses identica feed for tunes
    _1234... -> plays track from memory
    expression -> compiles and plays expression
    [else] -> searches greedily for a valid expression; if not found, ignores

bytetros?



void proc_token()

int[32] itable
struct { node* car, nlist* cdr } nlist
tlist* tcons(token*, )

struct { } token
token[140] ttable
struct { char type, int* iptr, int * } node
ntable[140]
int h2i(char*)


s-exp method:
tokenize: glom numbers
preparse: match parens, return s-expr
parse: turn into prefix notation
validate: check against rules
compile: optionally remove trivial identities ("~~") and evaluate static expressions

general method:
grammar parser, returns ast

----------

MACHINE:

struct { char type, char cval, int ival, node* lval, node* rval } node

types:
    n number
    v variable
    b binary operator
    u unary operator

SEXP 
